# 操作数据库

#### Django配置连接数据库：

在操作数据库之前，首先先要连接数据库。这里我们以配置`MySQL`为例来讲解。`Django`连接数据库，不需要单独的创建一个连接对象。只需要在`settings.py`文件中做好数据库相关的配置就可以了。示例代码如下：

```python
DATABASES = {
    'default': {
        # 数据库引擎（是mysql还是oracle等）
        'ENGINE': 'django.db.backends.mysql',
        # 数据库的名字
        'NAME': 'dfz',
        # 连接mysql数据库的用户名
        'USER': 'root',
        # 连接mysql数据库的密码
        'PASSWORD': 'root',
        # mysql数据库的主机地址
        'HOST': '127.0.0.1',
        # mysql数据库的端口号
        'PORT': '3306',
    }
}

```

## 在Django中操作数据库：

在`Django`中操作数据库有两种方式。第一种方式就是使用`原生sql语句`操作，第二种就是使用`ORM`模型来操作。

在`Django`中使用原生`sql`语句操作其实就是使用`python db api`的接口来操作。如果你的`mysql`驱动使用的是`pymysql`，那么你就是使用`pymysql`来操作的，只不过`Django`将数据库连接的这一部分封装好了，我们只要在`settings.py`中配置好了数据库连接信息后直接使用`Django`封装好的接口就可以操作了。示例代码如下：

```python
# 使用django封装好的connection对象，会自动读取settings.py中数据库的配置信息
from django.db import connection

# 获取游标对象
cursor = connection.cursor()
# 拿到游标对象后执行sql语句
cursor.execute("select * from book")
# 获取所有的数据
rows = cursor.fetchall()
# 遍历查询到的数据
for row in rows:
    print(row)

```

以上的`execute`以及`fetchall`方法都是`Python DB API`规范中定义好的。任何使用`Python`来操作`MySQL`的驱动程序都应该遵循这个规范。所以不管是使用`pymysql`或者是`mysqlclient`或者是`mysqldb`，他们的接口都是一样的。更多规范请参考：[https://www.python.org/dev/peps/pep-0249/。](https://www.python.org/dev/peps/pep-0249/。)

## Python DB API下规范下cursor对象常用接口：

1.  `description`：如果`cursor`执行了查询的`sql`代码。那么读取`cursor.description`属性的时候，将返回一个列表，这个列表中装的是元组，元组中装的分别是`(name,type_code,display_size,internal_size,precision,scale,null_ok)`，u其中`name`代表的是查找出来的数据的字段名称，其他参数暂时用处不大。

2.  `rowcount`：代表的是在执行了`sql`语句后受影响的行数。

3.  `close`：关闭游标。关闭游标以后就再也不能使用了，否则会抛出异常。

4. `execute(sql[,parameters])`：执行某个`sql`语句。如果在执行`sql`语句的时候还需要传递参数，那么可以传给`parameters`参数。

    示例代码如下：

    ```
     cursor.execute("select * from article where id=%s",(1,))
    
    ```

5. `fetchone`：在执行了查询操作以后，获取第一条数据。

6. `fetchmany(size)`：在执行查询操作以后，获取多条数据。具体是多少条要看传的`size`参数。如果不传`size`参数，那么默认是获取第一条数据。

7. `fetchall`：获取所有满足`sql`语句的数据。

# ORM模型介绍

随着项目越来越大，采用写原生SQL的方式在代码中会出现大量的SQL语句，那么问题就出现了：

1.  SQL语句重复利用率不高，越复杂的SQL语句条件越多，代码越长。会出现很多相近的SQL语句。
2.  很多SQL语句是在业务逻辑中拼出来的，如果有数据库需要更改，就要去修改这些逻辑，这会很容易漏掉对某些SQL语句的修改。
3.  写SQL时容易忽略web安全问题，给未来造成隐患。SQL注入。

`ORM`，全称`Object Relational Mapping`，中文叫做`对象关系映射`，通过`ORM`我们可以通过类的方式去操作数据库，而不用再写原生的SQL语句。通过把表映射成类，把行作实例，把字段作为属性，`ORM`在执行对象操作的时候最终还是会把对应的操作转换为数据库原生语句。使用`ORM`有许多优点：

1.  `易用性`：使用`ORM`做数据库的开发可以有效的减少重复SQL语句的概率，写出来的模型也更加直观、清晰。
2.  `性能损耗小`：`ORM`转换成底层数据库操作指令确实会有一些开销。但从实际的情况来看，这种性能损耗很少（不足5%），只要不是对性能有严苛的要求，综合考虑开发效率、代码的阅读性，带来的好处要远远大于性能损耗，而且项目越大作用越明显。
3.  `设计灵活`：可以轻松的写出复杂的查询。
4.  `可移植性`：`Django`封装了底层的数据库实现，支持多个关系数据库引擎，包括流行的`MySQL`、`PostgreSQL`和`SQLite`。可以非常轻松的切换数据库。

![{5FBC741F-4B24-05FE-8725-63C0ECC096DB}.png](https://upload-images.jianshu.io/upload_images/15336901-1c9d070ca8019a72.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)


## 创建ORM模型：

`ORM`模型一般都是放在`app`的`models.py`文件中。每个`app`都可以拥有自己的模型。并且如果这个模型想要映射到数据库中，那么这个`app`必须要放在`settings.py`的`INSTALLED_APP`中进行安装。以下是写一个简单的书籍`ORM`模型。示例代码如下：

```python
from django.db import models
from datetime import datetime
class Book(models.Model):
    name = models.CharField(max_length=20,null=False)
    author = models.CharField(max_length=20,null=False)
    pub_time = models.DateTimeField(default=datetime.now)
    price = models.FloatField(default=0)

```

以上便定义了一个模型。这个模型继承自`django.db.models.Model`，如果这个模型想要映射到数据库中，就必须继承自这个类。这个模型以后映射到数据库中，表名是模型名称的小写形式，为`book`。

在这个表中，有四个字段，一个为`name`，这个字段是保存的是书的名称，是`varchar`类型，最长不能超过20个字符，并且不能为空。第二个字段是作者名字类型，同样也是`varchar`类型，长度不能超过20个。第三个是出版时间，数据类型是`datetime`类型，默认是保存这本书籍的时间。第五个是这本书的价格，是浮点类型。
还有一个字段我们没有写，就是主键`id`，在`django`中，如果一个模型没有定义主键，那么将会自动生成一个自动增长的`int`类型的主键，并且这个主键的名字就叫做`id`。

## 映射模型到数据库中:

将`ORM`模型映射到数据库中，总结起来就是以下几步：

1.  在`settings.py`中，配置好`DATABASES`，做好数据库相关的配置。
2.  在`app`中的`models.py`中定义好模型，这个模型必须继承自`django.db.models`。
3.  将这个`app`添加到`settings.py`的`INSTALLED_APP`中。
4.  在命令行终端，进入到项目所在的路径，然后执行命令`python manage.py makemigrations`来生成迁移脚本文件。
5.  同样在命令行中，执行命令`python manage.py migrate`来将迁移脚本文件映射到数据库中。

# 模型常用属性

## 常用字段：

在`Django`中，定义了一些`Field`来与数据库表中的字段类型来进行映射。以下将介绍那些常用的字段类型。

### AutoField：

映射到数据库中是`int`类型，可以有自动增长的特性。一般不需要使用这个类型，如果不指定主键，那么模型会自动的生成一个叫做`id`的自动增长的主键。如果你想指定一个其他名字的并且具有自动增长的主键，使用`AutoField`也是可以的。

### BigAutoField：

64位的整形，类似于`AutoField`，只不过是产生的数据的范围是从`1-9223372036854775807`。

### BooleanField：

在模型层面接收的是`True/False`。在数据库层面是`tinyint`类型。如果没有指定默认值，默认值是`None`。

### CharField：

在数据库层面是`varchar`类型。在`Python`层面就是普通的字符串。这个类型在使用的时候必须要指定最大的长度，也即必须要传递`max_length`这个关键字参数进去。(记住这点)

### DateField：

日期类型。在`Python`中是`datetime.date`类型，可以记录年月日。在映射到数据库中也是`date`类型。使用这个`Field`可以传递以下几个参数：

1.  `auto_now`：在每次这个数据保存的时候，都使用当前的时间。比如作为一个**记录修改日期**的字段，可以将这个属性设置为`True`。
2.  `auto_now_add`：在每次数据第一次被添加进去的时候，都使用当前的时间。比如作为一个记录第一次入库的字段，可以将这个属性设置为`True`。

### DateTimeField：

日期时间类型，类似于`DateField`。不仅仅可以存储日期，还可以存储时间。映射到数据库中是`datetime`类型。这个`Field`也可以使用`auto_now`和`auto_now_add`两个属性。

### TimeField：

时间类型。在数据库中是`time`类型。在`Python`中是`datetime.time`类型。

### EmailField：

类似于`CharField`。在数据库底层也是一个`varchar`类型。最大长度是254个字符。

### FileField：

用来存储文件的。这个请参考后面的文件上传章节部分。

### ImageField：

用来存储图片文件的。这个请参考后面的图片上传章节部分。

### FloatField：

浮点类型。映射到数据库中是`float`类型。

### IntegerField：

整形。值的区间是`-2147483648——2147483647`。

### BigIntegerField：

大整形。值的区间是`-9223372036854775808——9223372036854775807`。

### PositiveIntegerField：

正整形。值的区间是`0——2147483647`。

### SmallIntegerField：

小整形。值的区间是`-32768——32767`。

### PositiveSmallIntegerField：

正小整形。值的区间是`0——32767`。

### TextField：

大量的文本类型。映射到数据库中是longtext类型。

### UUIDField：

只能存储`uuid`格式的字符串。`uuid`是一个32位的全球唯一的字符串，一般用来作为`主键`。

### URLField：

类似于`CharField`，只不过只能用来存储`url`格式的字符串。并且默认的`max_length`是200。

* * *

## Field的常用参数：

### null：

如果设置为`True`，`Django`将会在映射表的时候指定是否为空。默认是为`False`。在使用字符串相关的`Field`（CharField/TextField）的时候，官方推荐尽量不要使用这个参数，也就是保持默认值`False`。

因为`Django`在处理字符串相关的`Field`的时候，即使这个`Field`的`null=False`，如果你没有给这个`Field`传递任何值，那么`Django`也会使用一个空的字符串`""`来作为默认值存储进去。因此如果再使用`null=True`，`Django`会产生两种空值的情形（NULL或者空字符串）。

如果想要在表单验证的时候允许这个字符串为空，那么建议使用`blank=True`。如果你的`Field`是`BooleanField`，那么对应的可空的字段则为`NullBooleanField`。

### blank：

标识这个字段在表单验证的时候是否可以为空。默认是`False`。
这个和`null`是有区别的，`null`是一个纯数据库级别的。而`blank`是表单验证级别的。

### db_column：

这个字段指在数据库中的名字。如果没有设置这个参数，那么将会使用模型中属性的名字。

### default：

默认值。可以为一个值，或者是一个函数，但是不支持`lambda`表达式。并且不支持列表/字典/集合等可变的数据结构。

### primary_key：

是否为主键。默认是`False`。

### unique：

在表中这个字段的值是否唯一。一般是设置手机号码/邮箱等。

更多`Field`参数请参考官方文档：[https://docs.djangoproject.com/zh-hans/2.0/ref/models/fields/](https://docs.djangoproject.com/zh-hans/2.0/ref/models/fields/)

## 模型中`Meta`配置：

对于一些模型级别的配置。我们可以在模型中定义一个类，叫做`Meta`。然后在这个类中添加一些类属性来控制模型的作用。

比如我们想要在数据库映射的时候使用自己指定的表名，而不是使用模型的名称。那么我们可以在`Meta`类中添加一个`db_table`的属性。示例代码如下：

```python
class Book(models.Model):
    name = models.CharField(max_length=20,null=False)
    desc = models.CharField(max_length=100,name='description',db_column="description1")

    class Meta:
        db_table = 'book_model'

```

以下将对`Meta`类中的一些常用配置进行解释。

### db_table：

这个模型映射到数据库中的表名。如果没有指定这个参数，那么在映射的时候将会使用模型名来作为默认的表名。

### ordering：

设置在提取数据的排序方式。后面章节会讲到如何查找数据。比如我想在查找数据的时候根据添加的时间排序，那么示例代码如下：

```python
class Book(models.Model):
    name = models.CharField(max_length=20,null=False)
    desc = models.CharField(max_length=100,name='description',db_column="description1")
    pub_date = models.DateTimeField(auto_now_add=True)

    class Meta:
        db_table = 'book_model'
        ordering = ['pub_date']

```

更多的配置后面会慢慢介绍。
官方文档：[https://docs.djangoproject.com/en/2.0/ref/models/options/](https://docs.djangoproject.com/en/2.0/ref/models/options/)
# 外键和表关系
### 外键：
在MySQL中，表有两种引擎，一种是InnoDB，另外一种是myisam。如果使用的是InnoDB引擎，是支持外键约束的。外键的存在使得ORM框架在处理表关系的时候异常的强大。因此这里我们首先来介绍下外键在Django中的使用。

### 类定义为class ForeignKey(to,on_delete,**options)。

第一个参数是引用的是哪个模型，第二个参数是在使用外键引用的模型数据被删除了，这个字段该如何处理，比如有CASCADE、SET_NULL等。

这里以一个实际案例来说明。比如有一个User和一个Article两个模型。一个User可以发表多篇文章，一个Article只能有一个Author，并且通过外键进行引用。那么相关的示例代码如下：

```python
class User(models.Model):
    username = models.CharField(max_length=20)
    password = models.CharField(max_length=100)


class Article(models.Model):
    title = models.CharField(max_length=100)
    content = models.TextField()

    author = models.ForeignKey("User",on_delete=models.CASCADE)
```
以上使用ForeignKey来定义模型之间的关系。即在article的实例中可以通过author属性来操作对应的User模型。这样使用起来非常的方便。示例代码如下：
```python
article = Article(title='abc',content='123')
author = User(username='张三',password='111111')
article.author = author
article.save()

# 修改article.author上的值
article.author.username = '李四'
article.save()
```
为什么使用了ForeignKey后，就能通过author访问到对应的user对象呢。因此在底层，Django为Article表添加了一个属性名_id的字段（比如author的字段名称是author_id），这个字段是一个外键，记录着对应的作者的主键。以后通过article.author访问的时候，实际上是先通过author_id找到对应的数据，然后再提取User表中的这条数据，形成一个模型。

如果想要引用另外一个app的模型，那么应该在传递to参数的时候，使用app.model_name进行指定。以上例为例，如果User和Article不是在同一个app中，那么在引用的时候的示例代码如下：
```python
# User模型在user这个app中
class User(models.Model):
    username = models.CharField(max_length=20)
    password = models.CharField(max_length=100)

# Article模型在article这个app中
class Article(models.Model):
    title = models.CharField(max_length=100)
    content = models.TextField()

    author = models.ForeignKey("user.User",on_delete=models.CASCADE)
```
如果模型的外键引用的是本身自己这个模型，那么to参数可以为'self'，或者是这个模型的名字。在论坛开发中，一般评论都可以进行二级评论，即可以针对另外一个评论进行评论，那么在定义模型的时候就需要使用外键来引用自身。示例代码如下：
```python
class Comment(models.Model):
    content = models.TextField()
    origin_comment = models.ForeignKey('self',on_delete=models.CASCADE,null=True)
    # 或者
    # origin_comment = models.ForeignKey('Comment',on_delete=models.CASCADE,null=True)
```
### 外键删除操作：
如果一个模型使用了外键。那么在对方那个模型被删掉后，该进行什么样的操作。可以通过on_delete来指定。

可以指定的类型如下：

**CASCADE**：级联操作。如果外键对应的那条数据被删除了，那么这条数据也会被删除。
**PROTECT**：受保护。即只要这条数据引用了外键的那条数据，那么就不能删除外键的那条数据。
**SET_NULL**：设置为空。如果外键的那条数据被删除了，那么在本条数据上就将这个字段设置为空。如果设置这个选项，前提是要指定这个字段可以为空。
**SET_DEFAULT**：设置默认值。如果外键的那条数据被删除了，那么本条数据上就将这个字段设置为默认值。如果设置这个选项，前提是要指定这个字段一个默认值。
**SET()**：如果外键的那条数据被删除了。那么将会获取SET函数中的值来作为这个外键的值。SET函数可以接收一个可以调用的对象（比如函数或者方法），如果是可以调用的对象，那么会将这个对象调用后的结果作为值返回回去。
**DO_NOTHING**：不采取任何行为。一切全看数据库级别的约束。
以上这些选项只是Django级别的，数据级别依旧是RESTRICT！

### 表关系：
表之间的关系都是通过外键来进行关联的。而表之间的关系，无非就是三种关系：一对一、一对多（多对一）、多对多等。以下将讨论一下三种关系的应用场景及其实现方式。

### 一对多：
**应用场景**：比如文章和作者之间的关系。一个文章只能由一个作者编写，但是一个作者可以写多篇文章。文章和作者之间的关系就是典型的多对一的关系。
**实现方式**：一对多或者多对一，都是通过ForeignKey来实现的。还是以文章和作者的案例进行讲解。

```python
 class User(models.Model):
     username = models.CharField(max_length=20)
     password = models.CharField(max_length=100)

 class Article(models.Model):
     title = models.CharField(max_length=100)
     content = models.TextField()
     author = models.ForeignKey("User",on_delete=models.CASCADE)
```
那么以后在给Article对象指定author，就可以使用以下代码来完成：
```python
article = Article(title='abc',content='123')
author = User(username='zhiliao',password='111111')
# 要先保存到数据库中
author.save()
article.author = author
article.save() # 这里有点迷糊，谁是谁的外键？
```
并且以后如果想要获取某个用户下所有的文章，可以通过**article_set**来实现。  
示例代码如下：

```python
user = User.objects.first()
# 获取第一个用户写的所有文章
articles = user.article_set.all()
for article in articles:
    print(article)
```
### 一对一：
**应用场景**：比如一个用户表和一个用户信息表。在实际网站中，可能需要保存用户的许多信息，但是有些信息是不经常用的。如果把所有信息都存放到一张表中可能会影响查询效率，因此可以把用户的一些不常用的信息存放到另外一张表中我们叫做UserExtension。但是用户表User和用户信息表UserExtension就是典型的一对一了。

**实现方式**：Django为一对一提供了一个专门的Field叫做OneToOneField来实现一对一操作。  
示例代码如下：

```python
 class User(models.Model):
     username = models.CharField(max_length=20)
     password = models.CharField(max_length=100)

 class UserExtension(models.Model):  
     birthday = models.DateTimeField(null=True)  
     school = models.CharField(blank=True,max_length=50)  
     user = models.OneToOneField("User", on_delete=models.CASCADE)
```
在UserExtension模型上增加了一个一对一的关系映射。其实底层是在UserExtension这个表上增加了一个user_id，来和user表进行关联，并且这个外键数据在表中必须是唯一的，来保证一对一。

### 多对多：
**应用场景**：比如文章和标签的关系。一篇文章可以有多个标签，一个标签可以被多个文章所引用。因此标签和文章的关系是典型的多对多的关系。

**实现方式**：Django为这种多对多的实现提供了专门的Field。叫做ManyToManyField。还是拿文章和标签为例进行讲解。  
示例代码如下：

```python
 class Article(models.Model):
     title = models.CharField(max_length=100)
     content = models.TextField()
     tags = models.ManyToManyField("Tag",related_name="articles")

 class Tag(models.Model):
     name = models.CharField(max_length=50)
```
在数据库层面，实际上Django是为这种多对多的关系建立了一个中间表。这个中间表分别定义了两个外键，引用到article和tag两张表的主键。

## related_name和related_query_name：
### related_name：
还是以User和Article为例来进行说明。如果一个article想要访问对应的作者，那么可以通过author来进行访问。但是如果有一个user对象，想要通过这个user对象获取所有的文章，该如何做呢？这时候可以通过user.article_set来访问，这个名字的规律是模型名字小写_set。  
示例代码如下：

```python
user = User.objects.get(name='张三')
user.article_set.all()
```
如果不想使用模型名字小写_set的方式，想要使用其他的名字，那么可以在定义模型的时候指定related_name。  
示例代码如下：
```python
class Article(models.Model):
    title = models.CharField(max_length=100)
    content = models.TextField()
    # 传递related_name参数，以后在方向引用的时候使用articles进行访问
    author = models.ForeignKey("User",on_delete=models.SET_NULL,null=True,related_name='articles')
```
以后在反向引用的时候。使用articles可以访问到这个作者的文章模型。  
示例代码如下：

```python
user = User.objects.get(name='张三')
user.articles.all()
```
如果不想使用反向引用，那么可以指定related_name='+'。  
示例代码如下：

```python
class Article(models.Model):
    title = models.CharField(max_length=100)
    content = models.TextField()
    # 传递related_name参数，以后在方向引用的时候使用articles进行访问
    author = models.ForeignKey("User",on_delete=models.SET_NULL,null=True,related_name='+')
```
以后将不能通过user.article_set来访问文章模型了。

### related_query_name：
在查找数据的时候，可以使用filter进行过滤。使用filter过滤的时候，不仅仅可以指定本模型上的某个属性要满足什么条件，还可以指定相关联的模型满足什么属性。比如现在想要获取写过标题为abc的所有用户，那么可以这样写：
```python
users = User.objects.filter(article__title='abc')
```
如果你设置了related_name为articles，因为反转的过滤器的名字将使用related_name的名字，那么上例代码将改成如下：
```python
users = User.objects.filter(articles__title='abc')
```
可以通过related_query_name将查询的反转名字修改成其他的名字。比如article。  
示例代码如下：
```python
class Article(models.Model):
    title = models.CharField(max_length=100)
    content = models.TextField()
    # 传递related_name参数，以后在方向引用的时候使用articles进行访问
    author = models.ForeignKey("User",on_delete=models.SET_NULL,null=True,related_name='articles',related_query_name='article')
```
那么在做反向过滤查找的时候就可以使用以下代码：
```python
users = User.objects.filter(article__title='abc')
```

## 模型的操作：
在ORM框架中，所有模型相关的操作，比如添加/删除等。其实都是映射到数据库中一条数据的操作。因此模型操作也就是数据库表中数据的操作。

### 添加一个模型到数据库中：
添加模型到数据库中。首先需要创建一个模型。创建模型的方式很简单，就跟创建普通的Python对象是一摸一样的。在创建完模型之后，需要调用模型的save方法，这样Django会自动的将这个模型转换成sql语句，然后存储到数据库中。示例代码如下：
```python
class Book(models.Model):
    name = models.CharField(max_length=20,null=False)
    desc = models.CharField(max_length=100,name='description',db_column="description1")
    pub_date = models.DateTimeField(auto_now_add=True)

book = Book(name='三国演义',desc='三国英雄！')
book.save()
```
### 查找数据：
查找数据都是通过模型下的objects对象来实现的。

### 查找所有数据：
要查找Book这个模型对应的表下的所有数据。那么示例代码如下：
```
books = Book.objects.all()
```
以上将返回Book模型下的所有数据。

### 数据过滤：
在查找数据的时候，有时候需要对一些数据进行过滤。那么这时候需要调用objects的filter方法。实例代码如下：
```python
books = Book.objects.filter(name='三国演义')
> [<Book:三国演义>]

# 多个条件
books = Book.objects.filter(name='三国演义',desc='test')
# 调用filter，会将所有满足条件的模型对象都返回。
```

### 获取单个对象：
使用filter返回的是所有满足条件的结果集。有时候如果只需要返回第一个满足条件的对象。那么可以使用get方法。  
示例代码如下：
```python
book = Book.objects.get(name='三国演义')
> <Book:三国演义>
```
当然，如果没有找到满足条件的对象，那么就会**抛出一个异常**。而filter在没有找到满足条件的数据的时候，是**返回一个空的列表**。(这是和filter的区别)

### 数据排序：
在之前的例子中，数据都是无序的。如果你想在查找数据的时候使用某个字段来进行排序，那么可以使用order_by方法来实现。  
示例代码如下：
```python
books = Book.objects.order_by("pub_date")
```
以上代码在提取所有书籍的数据的时候，将会使用pub_date从小到大进行排序。如果想要进行倒序排序，那么可以在pub_date前面加一个**负号**。实例代码如下：
```python
books = Book.objects.order_by("-pub_date")
```
### 修改数据：
在查找到数据后，便可以进行修改了。修改的方式非常简单，只需要将查找出来的对象的某个属性进行修改，然后再调用这个对象的save方法便可以进行修改。  
示例代码如下：
```python
from datetime import datetime
book = Book.objects.get(name='三国演义')
book.pub_date = datetime.now()
book.save()
```
### 删除数据：
在查找到数据后，便可以进行删除了。删除数据非常简单，只需要调用这个对象的delete方法即可。实例代码如下：
```python
book = Book.objects.get(name='三国演义')
book.delete()
```

不管是修改还是删除数据，都要先找个那个数据，在对其进行操作

## 查询操作

查找是数据库操作中一个非常重要的技术。查询一般就是使用`filter`、`exclude`以及`get`三个方法来实现。我们可以在调用这些方法的时候传递不同的参数来实现查询需求。在`ORM`层面，这些查询条件都是使用**`field`+`__`+`condition`**的方式来使用的。以下将那些常用的查询条件来一一解释。

## 查询条件

### exact：

使用精确的`=`进行查找。如果提供的是一个`None`，那么在`SQL`层面就是被解释为`NULL`。示例代码如下：

```python
article = Article.objects.get(id__exact=14)
article = Article.objects.get(id__exact=None)

```

以上的两个查找在翻译为`SQL`语句为如下：

```sql
select ... from article where id=14;
select ... from article where id IS NULL;

```

### iexact：

使用`like`进行查找。示例代码如下：

```python
article = Article.objects.filter(title__iexact='hello world')

```

那么以上的查询就等价于以下的`SQL`语句：

```sql
select ... from article where title like 'hello world';

```

注意上面这个`sql`语句，因为在`MySQL`中，没有一个叫做`ilike`的。所以`exact`和`iexact`的区别实际上就是`LIKE`和`=`的区别，在大部分`collation=utf8_general_ci`情况下都是一样的（`collation`是用来对字符串比较的）。

### contains：

**大小写敏感**，判断某个字段是否包含了某个数据。示例代码如下：

```python
articles = Article.objects.filter(title__contains='hello')

```

在翻译成`SQL`语句为如下：

```sql
select ... where title like binary '%hello%';

```

要注意的是，在使用`contains`的时候，翻译成的`sql`语句左右两边是有百分号的，意味着使用的是模糊查询。而`exact`翻译成`sql`语句左右两边是没有百分号的，意味着使用的是精确的查询。

### icontains：

大小写不敏感的匹配查询。示例代码如下：

```python
articles = Article.objects.filter(title__icontains='hello')

```

在翻译成`SQL`语句为如下：

```sql
select ... where title like '%hello%';

```

### in：

提取那些给定的`field`的值是否在给定的容器中。容器可以为`list`、`tuple`或者任何一个可以迭代的对象，包括`QuerySet`对象。示例代码如下：

```python
articles = Article.objects.filter(id__in=[1,2,3])

```

以上代码在翻译成`SQL`语句为如下：

```sql
select ... where id in (1,3,4)

```

当然也可以传递一个`QuerySet`对象进去。示例代码如下：

```python
inner_qs = Article.objects.filter(title__contains='hello')
categories = Category.objects.filter(article__in=inner_qs)

```

以上代码的意思是获取那些文章标题包含`hello`的所有分类。
将翻译成以下`SQL`语句，示例代码如下：

```sql
select ...from category where article.id in (select id from article where title like '%hello%');

```

### gt：

某个`field`的值要大于给定的值。示例代码如下：

```python
articles = Article.objects.filter(id__gt=4)

```

以上代码的意思是将所有`id`大于4的文章全部都找出来。
将翻译成以下`SQL`语句：

```sql
select ... where id > 4;

```

### gte：

类似于`gt`，是大于等于。

### lt：

类似于`gt`是小于。

### lte：

类似于`lt`，是小于等于。

### startswith：

判断某个字段的值是否是以某个值开始的。**大小写敏感**。示例代码如下：

```python
articles = Article.objects.filter(title__startswith='hello')

```

以上代码的意思是提取所有标题以`hello`字符串开头的文章。
将翻译成以下`SQL`语句：

```sql
select ... where title like 'hello%'

```

### istartswith：

类似于`startswith`，但是**大小写是不敏感**的。

### endswith：

判断某个字段的值是否以某个值结束。大小写敏感。示例代码如下：

```python
articles = Article.objects.filter(title__endswith='world')

```

以上代码的意思是提取所有标题以`world`结尾的文章。
将翻译成以下`SQL`语句：

```sql
select ... where title like '%world';

```

### iendswith：

类似于`endswith`，只不过大小写不敏感。

### range：

判断某个`field`的值是否在给定的区间中。示例代码如下：

```python
from django.utils.timezone import make_aware
from datetime import datetime
start_date = make_aware(datetime(year=2018,month=1,day=1))
end_date = make_aware(datetime(year=2018,month=3,day=29,hour=16))
articles = Article.objects.filter(pub_date__range=(start_date,end_date))

```

以上代码的意思是提取所有发布时间在`2018/1/1`到`2018/12/12`之间的文章。
将翻译成以下的`SQL`语句：

```sql
select ... from article where pub_time between '2018-01-01' and '2018-12-12'。

```

需要注意的是，以上提取数据，**不会包含最后一个值**。也就是不会包含`2018/12/12`的文章。
而且另外一个重点，因为我们在`settings.py`中指定了`USE_TZ=True`，并且设置了`TIME_ZONE='Asia/Shanghai'`，因此我们在提取数据的时候要使用`django.utils.timezone.make_aware`先将`datetime.datetime`从`navie`时间转换为`aware`时间。`make_aware`会将指定的时间转换为`TIME_ZONE`中指定的时区的时间。(关于这些时区好好研究一下)

### date：

针对某些`date`或者`datetime`类型的字段。可以指定`date`的范围。并且这个时间过滤，还可以使用链式调用。示例代码如下：

```python
articles = Article.objects.filter(pub_date__date=date(2018,3,29))

```

以上代码的意思是查找时间为`2018/3/29`这一天发表的所有文章。
将翻译成以下的`sql`语句：

```sql
select ... WHERE DATE(CONVERT_TZ(`front_article`.`pub_date`, 'UTC', 'Asia/Shanghai')) = 2018-03-29

```

注意，因为默认情况下`MySQL`的表中是没有存储时区相关的信息的。因此我们需要下载一些时区表的文件，然后添加到`Mysql`的配置路径中。如果你用的是`windows`操作系统。那么在`http://dev.mysql.com/downloads/timezones.html`下载`timezone_2018d_posix.zip - POSIX standard`。然后将下载下来的所有文件拷贝到`C:\ProgramData\MySQL\MySQL Server 5.7\Data\mysql`中，如果提示文件名重复，那么选择覆盖即可。
如果用的是`linux`或者`mac`系统，那么在命令行中执行以下命令：`mysql_tzinfo_to_sql /usr/share/zoneinfo | mysql -D mysql -u root -p`，然后输入密码，从系统中加载时区文件更新到`mysql`中。

### year：

根据年份进行查找。示例代码如下：

```python
articles = Article.objects.filter(pub_date__year=2018)
articles = Article.objects.filter(pub_date__year__gte=2017)

```

以上的代码在翻译成`SQL`语句为如下：

```sql
select ... where pub_date between '2018-01-01' and '2018-12-31';
select ... where pub_date >= '2017-01-01';

```

### month：

同`year`，根据月份进行查找。

### day：

同`year`，根据日期进行查找。

## week_day：

`Django 1.11`新增的查找方式。同`year`，根据星期几进行查找。1表示星期天，7表示星期六，`2-6`代表的是星期一到星期五。

### time：

根据时间进行查找。示例代码如下：

```python
articles = Article.objects.filter(pub_date__time=datetime.time(12,12,12));

```

以上的代码是获取每一天中12点12分12秒发表的所有文章。
更多的关于时间的过滤，请参考`Django`官方文档：`https://docs.djangoproject.com/en/2.0/ref/models/querysets/#range`。

### isnull：

根据值是否为空进行查找。示例代码如下：

```python
articles = Article.objects.filter(pub_date__isnull=False)

```

以上的代码的意思是获取所有发布日期不为空的文章。
将来翻译成`SQL`语句如下：

```sql
select ... where pub_date is not null;

```

### regex和iregex：

**大小写敏感和大小写不敏感**的正则表达式。示例代码如下：

```
articles = Article.objects.filter(title__regex=r'^hello')

```

以上代码的意思是提取所有标题以`hello`字符串开头的文章。
将翻译成以下的`SQL`语句：

```sql
select ... where title regexp binary '^hello';

```

`iregex`是大小写不敏感的。

## 根据关联的表进行查询：

假如现在有两个`ORM`模型，一个是`Article`，一个是`Category`。代码如下：

```python
class Category(models.Model):
    """文章分类表"""
    name = models.CharField(max_length=100)

class Article(models.Model):
    """文章表"""
    title = models.CharField(max_length=100,null=True)
    category = models.ForeignKey("Category",on_delete=models.CASCADE)

```

比如想要获取文章标题中包含"hello"的所有的分类。那么可以通过以下代码来实现：

```sql
categories = Category.object.filter(article__title__contains("hello"))

```

* * *

## 聚合函数：

如果你用原生`SQL`，则可以使用聚合函数来提取数据。比如提取某个商品销售的数量，那么可以使用`Count`，如果想要知道商品销售的平均价格，那么可以使用`Avg`。
聚合函数是通过`aggregate`方法来实现的。在讲解这些聚合函数的用法的时候，都是基于以下的模型对象来实现的。

```python
  from django.db import models

 class Author(models.Model):
     """作者模型"""
     name = models.CharField(max_length=100)
     age = models.IntegerField()
     email = models.EmailField()

     class Meta:
         db_table = 'author'

 class Publisher(models.Model):
     """出版社模型"""
     name = models.CharField(max_length=300)

     class Meta:
         db_table = 'publisher'

 class Book(models.Model):
     """图书模型"""
     name = models.CharField(max_length=300)
     pages = models.IntegerField()
     price = models.FloatField()
     rating = models.FloatField()
     author = models.ForeignKey(Author,on_delete=models.CASCADE)
     publisher = models.ForeignKey(Publisher, on_delete=models.CASCADE)

     class Meta:
         db_table = 'book'

 class BookOrder(models.Model):
     """图书订单模型"""
     book = models.ForeignKey("Book",on_delete=models.CASCADE)
     price = models.FloatField()

     class Meta:
         db_table = 'book_order'

```

### 1.  `Avg`：求平均值。
~~~python
比如想要获取所有图书的价格平均值。那么可以使用以下代码实现。

```
 from django.db.models import Avg
 result = Book.objects.aggregate(Avg('price'))
 print(result)

```

以上的打印结果是：

```
 {"price__avg":23.0}

```

其中`price__avg`的结构是根据`field__avg`规则构成的。如果想要修改默认的名字，那么可以将`Avg`赋值给一个关键字参数。示例代码如下：

```
 from django.db.models import Avg
 result = Book.objects.aggregate(my_avg=Avg('price'))
 print(result)

```

那么以上的结果打印为：

```
 {"my_avg":23}

```
~~~

### 2.  `Count`：获取指定的对象的个数。
~~~python
示例代码如下：

```
 from django.db.models import Count
 result = Book.objects.aggregate(book_num=Count('id'))

```

以上的`result`将返回`Book`表中总共有多少本图书。
`Count`类中，还有另外一个参数叫做`distinct`，默认是等于`False`，如果是等于`True`，那么将去掉那些重复的值。比如要获取作者表中所有的不重复的邮箱总共有多少个，那么可以通过以下代码来实现：

```
     from djang.db.models import Count
     result = Author.objects.aggregate(count=Count('email',distinct=True))

```
~~~

### 3.  `Max`和`Min`：获取指定对象的最大值和最小值。
~~~python
比如想要获取`Author`表中，最大的年龄和最小的年龄分别是多少。那么可以通过以下代码来实现：

```
 from django.db.models import Max,Min
 result = Author.objects.aggregate(Max('age'),Min('age'))

```

如果最大的年龄是88,最小的年龄是18。那么以上的result将为：

```
 {"age__max":88,"age__min":18}

```
~~~

### 4.  `Sum`：求指定对象的总和。
~~~python
比如要求图书的销售总额。那么可以使用以下代码实现：

```
 from djang.db.models import Sum
 result = Book.objects.annotate(total=Sum("bookstore__price")).values("name","total")

```

以上的代码`annotate`的意思是给`Book`表在查询的时候添加一个字段叫做`total`，这个字段的数据来源是从`BookStore`模型的`price`的总和而来。`values`方法是只提取`name`和`total`两个字段的值。
~~~

更多的聚合函数请参考官方文档：[https://docs.djangoproject.com/en/2.0/ref/models/querysets/#aggregation-functions](https://docs.djangoproject.com/en/2.0/ref/models/querysets/#aggregation-functions)

## aggregate和annotate的区别：

### 1.  `aggregate`：返回使用聚合函数后的字段和值。

### 2.  `annotate`：在原来模型字段的基础之上添加一个使用了聚合函数的字段，并且在使用聚合函数的时候，会使用当前这个模型的主键进行分组（group by）。
    比如以上`Sum`的例子，如果使用的是`annotate`，那么将在每条图书的数据上都添加一个字段叫做`total`，计算这本书的销售总额。
    而如果使用的是`aggregate`，那么将求所有图书的销售总额。

## F表达式和Q表达式：

### F表达式：

`F表达式`是用来优化`ORM`操作数据库的。比如我们要将公司所有员工的薪水都增加1000元，如果按照正常的流程，应该是先从数据库中提取所有的员工工资到Python内存中，然后使用Python代码在员工工资的基础之上增加1000元，最后再保存到数据库中。这里面涉及的流程就是，首先从数据库中提取数据到Python内存中，然后在Python内存中做完运算，之后再保存到数据库中。示例代码如下：

```python
employees = Employee.objects.all()
for employee in employees:
    employee.salary += 1000
    employee.save()

```

而我们的`F表达式`就可以优化这个流程，他可以不需要先把数据从数据库中提取出来，计算完成后再保存回去，他可以直接执行`SQL语句`，就将员工的工资增加1000元。示例代码如下：

```python
from djang.db.models import F
Employee.object.update(salary=F("salary")+1000)

```

`F表达式`并不会马上从数据库中获取数据，而是在生成`SQL`语句的时候，动态的获取传给`F表达式`的值。

比如如果想要获取作者中，`name`和`email`相同的作者数据。如果不使用`F表达式`，那么需要使用以下代码来完成：

```python
    authors = Author.objects.all()
    for author in authors:
        if author.name == author.email:
            print(author)

```

如果使用`F表达式`，那么一行代码就可以搞定。示例代码如下：

```python

    from django.db.models import F
    authors = Author.objects.filter(name=F("email"))

```

### Q表达式：

如果想要实现所有价格高于100元，并且评分达到9.0以上评分的图书。那么可以通过以下代码来实现：

```python
books = Book.objects.filter(price__gte=100,rating__gte=9)

```

以上这个案例是一个并集查询，可以简单的通过传递多个条件进去来实现。
但是如果想要实现一些复杂的查询语句，比如要查询所有价格低于10元，或者是评分低于9分的图书。那就没有办法通过传递多个条件进去实现了。这时候就需要使用`Q表达式`来实现了。示例代码如下：

```python
from django.db.models import Q
books = Book.objects.filter(Q(price__lte=10) | Q(rating__lte=9))

```

以上是进行或运算，当然还可以进行其他的运算，比如有`&`和`~（非）`等。一些用`Q`表达式的例子如下：

```python
from django.db.models import Q
# 获取id等于3的图书
books = Book.objects.filter(Q(id=3))
# 获取id等于3，或者名字中包含文字"记"的图书
books = Book.objects.filter(Q(id=3)|Q(name__contains("记")))
# 获取价格大于100，并且书名中包含"记"的图书
books = Book.objects.filter(Q(price__gte=100)&Q(name__contains("记")))
# 获取书名包含“记”，但是id不等于3的图书
books = Book.objects.filter(Q(name__contains='记') & ~Q(id=3))
```

# QuerySet API：

我们通常做查询操作的时候，都是通过`模型名字.objects`的方式进行操作。其实`模型名字.objects`是一个`django.db.models.manager.Manager`对象，而`Manager`这个类是一个“空壳”的类，他本身是没有任何的属性和方法的。他的方法全部都是通过`Python`动态添加的方式，从`QuerySet`类中拷贝过来的。示例图如下：
![QuerySet和Manager.png](https://upload-images.jianshu.io/upload_images/15336901-be94facba8d02e0b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)


所以我们如果想要学习`ORM`模型的查找操作，必须首先要学会`QuerySet`上的一些`API`的使用。

## 返回新的QuerySet的方法：

在使用`QuerySet`进行查找操作的时候，可以提供多种操作。比如过滤完后还要根据某个字段进行排序，那么这一系列的操作我们可以通过一个非常流畅的`链式调用`的方式进行。比如要从文章表中获取标题为`123`，并且提取后要将结果根据发布的时间进行排序，那么可以使用以下方式来完成：

```python
articles = Article.objects.filter(title='123').order_by('create_time')

```

可以看到`order_by`方法是直接在`filter`执行后调用的。这说明`filter`返回的对象是一个拥有`order_by`方法的对象。而这个对象正是一个新的`QuerySet`对象。因此可以使用`order_by`方法。

那么以下将介绍在那些会返回新的`QuerySet`对象的方法。

### 1.  `filter`：将满足条件的数据提取出来，返回一个新的`QuerySet`。

具体的`filter`可以提供什么条件查询。请见查询操作章节。

### 2.  `exclude`：排除满足条件的数据，返回一个新的`QuerySet`。

示例代码如下：
	
```python
Article.objects.exclude(title__contains='hello')
```

以上代码的意思是提取那些标题不包含`hello`的图书。

3.  `annotate`：给`QuerySet`中的每个对象都添加一个使用查询表达式（聚合函数、F表达式、Q表达式、Func表达式等）的新字段。
示例代码如下：
	
```python
articles = Article.objects.annotate(author_name=F("author__name"))
```

以上代码将在每个对象中都添加一个`author__name`的字段，用来显示这个文章的作者的年龄。

4.  `order_by`：指定将查询的结果根据某个字段进行排序。如果要倒叙排序，那么可以在这个字段的前面加一个负号。
示例代码如下：
	
```python
# 根据创建的时间正序排序
articles = Article.objects.order_by("create_time")
# 根据创建的时间倒序排序
articles = Article.objects.order_by("-create_time")
# 根据作者的名字进行排序
articles = Article.objects.order_by("author__name")
# 首先根据创建的时间进行排序，如果时间相同，则根据作者的名字进行排序
articles = Article.objects.order_by("create_time",'author__name')
```

一定要注意的一点是，多个`order_by`，会把前面排序的规则给打乱，而使用后面的排序方式。比如以下代码：
	
```python
articles = Article.objects.order_by("create_time").order_by("author__name")	
```

他会根据作者的名字进行排序，而不是使用文章的创建时间。

### 5.`values`：用来指定在提取数据出来，需要提取哪些字段。

默认情况下会把表中所有的字段全部都提取出来，可以使用`values`来进行指定，并且使用了`values`方法后，提取出的`QuerySet`中的数据类型不是模型，而是在`values`方法中指定的字段和值形成的字典：

```python
 articles = Article.objects.values("title",'content')
 for article in articles:
     print(article)
```

以上打印出来的`article`是类似于`{"title":"abc","content":"xxx"}`的形式。
如果在`values`中没有传递任何参数，那么将会返回这个模型中所有的属性。


### 6.  `values_list`：类似于`values`。只不过返回的`QuerySet`中，存储的不是字典，而是元组。
示例代码如下：
```python
	 articles = Article.objects.values_list("id","title")
	 print(articles)
	
```

那么在打印`articles`后，结果为`<QuerySet [(1,'abc'),(2,'xxx'),...]>`等。
如果在`values_list`中只有一个字段。那么你可以传递`flat=True`来将结果扁平化。
示例代码如下：
	

```python
articles1 = Article.objects.values_list("title")
>> <QuerySet [("abc",),("xxx",),...]>
articles2 = Article.objects.values_list("title",flat=True)
>> <QuerySet ["abc",'xxx',...]>
	
```

### 7.  `all`：获取这个`ORM`模型的`QuerySet`对象。

### 8.  `select_related`：在提取某个模型的数据的同时，也提前将相关联的数据提取出来。
比如提取文章数据，可以使用`select_related`将`author`信息提取出来，以后再次使用`article.author`的时候就不需要再次去访问数据库了。可以减少数据库查询的次数。示例代码如下：

```python
article = Article.objects.get(pk=1)
>> article.author # 重新执行一次查询语句
article = Article.objects.select_related("author").get(pk=2)
>> article.author # 不需要重新执行查询语句了

```

`select_related`只能用在`一对多`或者`一对一`中，不能用在`多对多`或者`多对一`中。比如可以提前获取文章的作者，但是不能通过作者获取这个作者的文章，或者是通过某篇文章获取这个文章所有的标签。

### 9.  `prefetch_related`：这个方法和`select_related`非常的类似，就是在访问多个表中的数据的时候，减少查询的次数。
这个方法是为了解决`多对一`和`多对多`的关系的查询问题。比如要获取标题中带有`hello`字符串的文章以及他的所有标签，示例代码如下：

```python
from django.db import connection
articles = Article.objects.prefetch_related("tag_set").filter(title__contains='hello')
    print(articles.query) # 通过这条命令查看在底层的SQL语句
    for article in articles:
    print("title:",article.title)
    print(article.tag_set.all())

# 通过以下代码可以看出以上代码执行的sql语句
for sql in connection.queries:
print(sql)

```

但是如果在使用`article.tag_set`的时候，如果又创建了一个新的`QuerySet`那么会把之前的`SQL`优化给破坏掉。比如以下代码：
	
```python
tags = Tag.obejcts.prefetch_related("articles")
for tag in tags:
    articles = tag.articles.filter(title__contains='hello') #因为filter方法会重新生成一个QuerySet，因此会破坏掉之前的sql优化

    # 通过以下代码，我们可以看到在使用了filter的，他的sql查询会更多，而没有使用filter的，只有两次sql查询
    for sql in connection.queries:
        print(sql)

```

那如果确实是想要在查询的时候指定过滤条件该如何做呢，这时候我们可以使用`django.db.models.Prefetch`来实现，`Prefetch`这个可以提前定义好`queryset`。示例代码如下：
	
```python
tags = Tag.objects.prefetch_related(Prefetch("articles",queryset=Article.objects.filter(title__contains='hello'))).all()
for tag in tags:
    articles = tag.articles.all()
    for article in articles:
        print(article)

        for sql in connection.queries:
            print('='*30)
            print(sql)

```

因为使用了`Prefetch`，即使在查询文章的时候使用了`filter`，也只会发生两次查询操作。

### 10.  `defer`：在一些表中，可能存在很多的字段，但是一些字段的数据量可能是比较庞大的，而此时你又不需要，
比如我们在获取文章列表的时候，文章的内容我们是不需要的，因此这时候我们就可以使用`defer`来过滤掉一些字段。这个字段跟`values`有点类似，只不过`defer`返回的不是字典，而是模型。示例代码如下：
	
```python
articles = list(Article.objects.defer("title"))
for sql in connection.queries:
    print('='*30)
    print(sql)

```

在看以上代码的`sql`语句，你就可以看到，查找文章的字段，除了`title`，其他字段都查找出来了。当然，你也可以使用`article.title`来获取这个文章的标题，但是会重新执行一个查询的语句。示例代码如下：
	
```python
articles = list(Article.objects.defer("title"))
for article in articles:
    # 因为在上面提取的时候过滤了title
    # 这个地方重新获取title，将重新向数据库中进行一次查找操作
    print(article.title)
    for sql in connection.queries:
        print('='*30)
        print(sql)

```

`defer`虽然能过滤字段，但是有些字段是不能过滤的，比如`id`，即使你过滤了，也会提取出来。

### 11.  `only`：跟`defer`类似，只不过`defer`是过滤掉指定的字段，而`only`是只提取指定的字段。

### 12.  `get`：获取满足条件的数据。
这个函数只能返回一条数据，并且如果给的条件有多条数据，那么这个方法会抛出`MultipleObjectsReturned`错误，如果给的条件没有任何数据，那么就会抛出`DoesNotExit`错误。所以这个方法在获取数据的只能，只能有且只有一条。

### 13.  `create`：创建一条数据，并且保存到数据库中。
这个方法相当于先用指定的模型创建一个对象，然后再调用这个对象的`save`方法。示例代码如下：
	
```python
article = Article(title='abc')
article.save()

# 下面这行代码相当于以上两行代码
article = Article.objects.create(title='abc')

```

### 14.  `get_or_create`：根据某个条件进行查找，如果找到了那么就返回这条数据，如果没有查找到，那么就创建一个。
示例代码如下：
	
```python
obj,created= Category.objects.get_or_create(title='默认分类')

```

如果有标题等于`默认分类`的分类，那么就会查找出来，如果没有，则会创建并且存储到数据库中。
这个方法的返回值是一个元组，元组的第一个参数`obj`是这个对象，第二个参数`created`代表是否创建的。

### 15.  `bulk_create`：一次性创建多个数据。
示例代码如下：

```python
Tag.objects.bulk_create([
Tag(name='111'),
Tag(name='222'),
])

```

16.  `count`：获取提取的数据的个数。如果想要知道总共有多少条数据，那么建议使用`count`，而不是使用`len(articles)`这种。因为`count`在底层是使用`select count(*)`来实现的，这种方式比使用`len`函数更加的高效。

### 17.  `first`和`last`：返回`QuerySet`中的第一条和最后一条数据。

### 18.  `aggregate`：使用聚合函数。

### 19.  `exists`：判断某个条件的数据是否存在。如果要判断某个条件的元素是否存在，那么建议使用`exists`，这比使用`count`或者直接判断`QuerySet`更有效得多。
示例代码如下：
	
```python
if Article.objects.filter(title__contains='hello').exists():
    print(True)
    比使用count更高效：
    if Article.objects.filter(title__contains='hello').count() > 0:
        print(True)
        也比直接判断QuerySet更高效：
        if Article.objects.filter(title__contains='hello'):
            print(True)

```

### 20.  `distinct`：去除掉那些重复的数据。
这个方法如果底层数据库用的是`MySQL`，那么不能传递任何的参数。比如想要提取所有销售的价格超过80元的图书，并且删掉那些重复的，那么可以使用`distinct`来帮我们实现，示例代码如下：
	
```
    books = Book.objects.filter(bookorder__price__gte=80).distinct()

```

需要注意的是，如果在`distinct`之前使用了`order_by`，那么因为`order_by`会提取`order_by`中指定的字段，因此再使用`distinct`就会根据多个字段来进行唯一化，所以就不会把那些重复的数据删掉。示例代码如下：
	
```
    orders = BookOrder.objects.order_by("create_time").values("book_id").distinct()

```

那么以上代码因为使用了`order_by`，即使使用了`distinct`，也会把重复的`book_id`提取出来。

### 21.  `update`：执行更新操作，在`SQL`底层走的也是`update`命令。
比如要将所有`category`为空的`article`的`article`字段都更新为默认的分类。示例代码如下：
	
```
    Article.objects.filter(category__isnull=True).update(category_id=3)

```

注意这个方法走的是更新的逻辑。所以更新完成后保存到数据库中不会执行`save`方法，因此不会更新`auto_now`设置的字段。

### 22.  `delete`：删除所有满足条件的数据。删除数据的时候，要注意`on_delete`指定的处理方式。

### 23.  切片操作：有时候我们查找数据，有可能只需要其中的一部分。
那么这时候可以使用切片操作来帮我们完成。`QuerySet`使用切片操作就跟列表使用切片操作是一样的。示例代码如下：
	
```python
    books = Book.objects.all()[1:3]
    for book in books:
    print(book)

```

切片操作并不是把所有数据从数据库中提取出来再做切片操作。而是在数据库层面使用`LIMIE`和`OFFSET`来帮我们完成。所以如果只需要取其中一部分的数据的时候，建议大家使用切片操作。

## 什么时候`Django`会将`QuerySet`转换为`SQL`去执行：

生成一个`QuerySet`对象并不会马上转换为`SQL`语句去执行。
比如我们获取`Book`表下所有的图书：

```python
books = Book.objects.all()
print(connection.queries)
```

我们可以看到在打印`connection.quries`的时候打印的是一个空的列表。说明上面的`QuerySet`并没有真正的执行。
在以下情况下`QuerySet`会被转换为`SQL`语句执行：

1.  迭代：在遍历`QuerySet`对象的时候，会首先先执行这个`SQL`语句，然后再把这个结果返回进行迭代。比如以下代码就会转换为`SQL`语句：

```python
for book in Book.objects.all():
print(book)
```

2.  使用步长做切片操作：`QuerySet`可以类似于列表一样做切片操作。做切片操作本身不会执行`SQL`语句，但是如果如果在做切片操作的时候提供了步长，那么就会立马执行`SQL`语句。需要注意的是，做切片后不能再执行`filter`方法，否则会报错。

3.  调用`len`函数：调用`len`函数用来获取`QuerySet`中总共有多少条数据也会执行`SQL`语句。

4.  调用`list`函数：调用`list`函数用来将一个`QuerySet`对象转换为`list`对象也会立马执行`SQL`语句。

5.  判断：如果对某个`QuerySet`进行判断，也会立马执行`SQL`语句。



# ORM模型迁移

## 迁移命令：

1.  **makemigrations**：将模型生成迁移脚本。模型所在的`app`，必须放在`settings.py`中的`INSTALLED_APPS`中。这个命令有以下几个常用选项：
*   **app_label**：后面可以跟一个或者多个`app`，那么就只会针对这几个app生成迁移脚本。如果没有任何的app_label，那么会检查`INSTALLED_APPS`中所有的app下的模型，针对每一个app都生成响应的迁移脚本。
    *   **--name**：给这个迁移脚本指定一个名字。
    *   **--empty**：生成一个空的迁移脚本。如果你想写自己的迁移脚本，可以使用这个命令来实现一个空的文件，然后自己再在文件中写迁移脚本。
2.  **migrate**：将新生成的迁移脚本。映射到数据库中。创建新的表或者修改表的结构。以下一些常用的选项：
*   **app_label**：将某个`app`下的迁移脚本映射到数据库中。如果没有指定，那么会将所有在`INSTALLED_APPS`中的`app`下的模型都映射到数据库中。
    *   **app_label migrationname**：将某个`app`下指定名字的`migration`文件映射到数据库中。
    *   **--fake**：可以将指定的迁移脚本名字添加到数据库中。但是并不会把迁移脚本转换为SQL语句，修改数据库中的表。
    *   **--fake-initial**：将第一次生成的迁移文件版本号记录在数据库中。但并不会真正的执行迁移脚本。
3.  **showmigrations**：查看某个app下的迁移文件。如果后面没有app，那么将查看`INSTALLED_APPS`中所有的迁移文件。

4.  **sqlmigrate**：查看某个迁移文件在映射到数据库中的时候，转换的`SQL`语句。

## migrations中的迁移版本和数据库中的迁移版本对不上怎么办？

1.  找到哪里不一致，然后使用`python manage.py --fake [版本名字]`，将这个版本标记为已经映射。
2.  删除指定`app`下`migrations`和数据库表`django_migrations`中和这个`app`相关的版本号，然后将模型中的字段和数据库中的字段保持一致，再使用命令`python manage.py makemigrations`重新生成一个初始化的迁移脚本，之后再使用命令`python manage.py makemigrations --fake-initial`来将这个初始化的迁移脚本标记为已经映射。以后再修改就没有问题了。

更多关于迁移脚本的。请查看官方文档：[https://docs.djangoproject.com/en/2.0/topics/migrations/](https://docs.djangoproject.com/en/2.0/topics/migrations/)

## 根据已有的表自动生成模型：

在实际开发中，有些时候可能数据库已经存在了。如果我们用`Django`来开发一个网站，读取的是之前已经存在的数据库中的数据。那么该如何将模型与数据库中的表映射呢？根据旧的数据库生成对应的`ORM`模型，需要以下几个步骤：

1.  `Django`给我们提供了一个`inspectdb`的命令，可以非常方便的将已经存在的表，自动的生成模型。想要使用`inspectdb`自动将表生成模型。首先需要在`settings.py`中配置好数据库相关信息。不然就找不到数据库。示例代码如下：

    ```python
     DATABASES = {
         'default': {
             'ENGINE': 'django.db.backends.mysql',
             'NAME': "migrations_demo",
             'HOST': '127.0.0.1',
             'PORT': '3306',
             'USER': 'root',
             'PASSWORD': 'root'
         }
     }

    ```

    比如有以下表：

    *   article表：
       ![article表.png](https://upload-images.jianshu.io/upload_images/15336901-6aede81da39b5c95.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

    *   tag表：
      ![tag表.png](https://upload-images.jianshu.io/upload_images/15336901-d0c23f87c5bb8a83.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)


    *   article_tag表：
      ![article_tag表.png](https://upload-images.jianshu.io/upload_images/15336901-9081fa25585c14d0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)


    *   front_user表：
       ![frontuser.png](https://upload-images.jianshu.io/upload_images/15336901-e6f0dcd2fb1abc58.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)


~~~python
    那么通过`python manage.py inspectdb`，就会将表转换为模型后的代码，显示在终端：

    ```python
    from django.db import models

    class ArticleArticle(models.Model):
      title = models.CharField(max_length=100)
      content = models.TextField(blank=True, null=True)
      create_time = models.DateTimeField(blank=True, null=True)
      author = models.ForeignKey('FrontUserFrontuser', models.DO_NOTHING, blank=True, null=True)

      class Meta:
          managed = False
          db_table = 'article_article'

    class ArticleArticleTags(models.Model):
      article = models.ForeignKey(ArticleArticle, models.DO_NOTHING)
      tag = models.ForeignKey('ArticleTag', models.DO_NOTHING)

      class Meta:
          managed = False
          db_table = 'article_article_tags'
          unique_together = (('article', 'tag'),)

    class ArticleTag(models.Model):
      name = models.CharField(max_length=100)

      class Meta:
          managed = False
          db_table = 'article_tag'

    class FrontUserFrontuser(models.Model):
      username = models.CharField(max_length=100)
      telephone = models.CharField(max_length=11)

      class Meta:
          managed = False
          db_table = 'front_user_frontuser'

    ```

    以上代码只是显示在终端。如果想要保存到文件中。那么可以使用`>`重定向输出到指定的文件。比如让他输出到`models.py`文件中。示例命令如下：

    ```shell
    python manage.py inspectdb > models.py

    ```

    以上的命令，只能在终端执行，不能在`pycharm->Tools->Run manage.py Task...`中使用。

    如果只是想要转换一个表为模型。那么可以指定表的名字。示例命令如下：

    ```shell
    python manage.py inspectdb article_article > models.py

    ```
~~~

2.  修正模型：新生成的`ORM`模型有些地方可能不太适合使用。比如模型的名字，表之间的关系等等。那么以下选项还需要重新配置一下：

    *   模型名：自动生成的模型，是根据表的名字生成的，可能不是你想要的。这时候模型的名字你可以改成任何你想要的。
    *   模型所属app：根据自己的需要，将相应的模型放在对应的app中。放在同一个app中也是没有任何问题的。只是不方便管理。
    *   模型外键引用：将所有使用`ForeignKey`的地方，模型引用都改成字符串。这样不会产生模型顺序的问题。另外，如果引用的模型已经移动到其他的app中了，那么还要加上这个app的前缀。
    *   让Django管理模型：将`Meta`下的`managed=False`删掉，如果保留这个，那么以后这个模型有任何的修改，使用`migrate`都不会映射到数据库中。
    *   当有多对多的时候，应该也要修正模型。将中间表注视了，然后使用`ManyToManyField`来实现多对多。并且，使用`ManyToManyField`生成的中间表的名字可能和数据库中那个中间表的名字不一致，这时候肯定就不能正常连接了。那么可以通过`db_table`来指定中间表的名字。示例代码如下：

        ```python
        from django.db import models
        class Article(models.Model):
         title = models.CharField(max_length=100, blank=True, null=True)
         content = models.TextField(blank=True, null=True)
         author = models.ForeignKey('front.User', models.SET_NULL, blank=True, null=True)
         # 使用ManyToManyField模型到表，生成的中间表的规则是：article_tags
         # 但现在已经存在的表的名字叫做：article_tag
         # 可以使用db_table，指定中间表的名字
         tags = models.ManyToManyField("Tag",db_table='article_tag')

         class Meta:
             db_table = 'article'

        ```

    *   表名：切记不要修改表的名字。不然映射到数据库中，会发生找不到对应表的错误。
3.  执行命令`python manage.py makemigrations`生成初始化的迁移脚本。方便后面通过`ORM`来管理表。这时候还需要执行命令`python manage.py migrate --fake-initial`，因为如果不使用`--fake-initial`，那么会将迁移脚本会映射到数据库中。这时候迁移脚本会新创建表，而这个表之前是已经存在了的，所以肯定会报错。此时我们只要将这个`0001-initial`的状态修改为已经映射，而不真正执行映射，下次再`migrate`的时候，就会忽略他。

4.  将`Django`的核心表映射到数据库中：`Django`中还有一些核心的表也是需要创建的。不然有些功能是用不了的。比如`auth`相关表。如果这个数据库之前就是使用`Django`开发的，那么这些表就已经存在了。可以不用管了。如果之前这个数据库不是使用`Django`开发的，那么应该使用`migrate`命令将`Django`中的核心模型映射到数据库中。
