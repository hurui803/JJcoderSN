# 函数基础

阅读: 10047   [评论](http://www.liujiangblog.com/course/python/30#comments)：1

在Python中，采用下面的语法定义函数：

```
def 函数名(参数):
    # 内部代码
    return 表达式 
```

例如：

```
def summer(lis):
    """
    这里是函数的说明文档，doc的位置
    :param lis: 参数列表的说明
    :return: 返回值的说明
    """
    total = 0
    for i in lis:
        total += i
    return total
```

在定义函数的过程中，需要注意以下几点：

- 函数代码块以`def`关键词开头，一个空格之后接函数标识符名称和圆括号()，再接个冒号。
- 任何传入的参数必须放在圆括号中间。
- 函数的第一行语句后可以选择性地使用文档字符串—用于存放函数说明。
- 函数内容以冒号起始，并且缩进。
- 使用return结束函数。默认返回None。
- return语句依然在函数体内部，不能回退缩进。直到函数的所有代码写完，才回退缩进，表示函数体结束。

**如何调用函数？**

函数编写出来就是给人调用的。要调用一个函数，必须使用函数名后跟圆括号的方式才能调用函数。调用的同时要根据函数的定义体，提供相应个数和类型的参数，每个参数之间用逗号分隔。Python由于动态语言的特点，在做语法和词法分析检查的时候，并不会对参数类型进行检查，但在执行过程中，如果参数类型不符合函数内部运行机制的话，会弹出相应的错误，例如：

```
>>> all(0, -1, 3)
Traceback (most recent call last):
  File "<pyshell#0>", line 1, in <module>
    all(0, -1, 3)
TypeError: all() takes exactly one argument (3 given)
>>> all([0, -1, 3])
False
```

Python内置函数all()要求提供一个参数，但我们一开始给了3个。后面，我们将三个参数作为一个整体列表提供就没有问题了。

**return语句：**

return语句用于表示函数执行到此结束，并且返回return后面的对象。有时候，函数不需要返回任何值，此时可以不需要return语句，它在后台默认给你返回个None，并且不给任何提示。但是更多的时候我们还是需要return一些东西。**一旦函数执行过程遇到return语句，那么之后函数体内的所有代码都会被忽略，直接跳出函数体**。那怕你现在正在一个循环内。

```
def func():
    pass
    return
    # 此时，后面的代码其实是永远无法执行的。
    # 但从语法和词法层面，这些没有错误。
    print(1)
    abs(-1)
    pass
```

**return可以返回什么？**

- 什么都不返回，仅仅return：`return`
- 数字/字符串/任意数据类型： `return 'hello'`
- 一个表达式：`return 1+2`
- 一个判断语句：`return 100 > 99`
- 一个变量：`return a`
- 一个函数调用：`return func()`
- 甚至是返回自己！：`return self`
- 多个返回值，以逗号分隔：`return a, 1+2, "hello"`

简而言之，函数可以return几乎任意Python对象。

**如何接收函数的返回值？**

我们在调用函数的时候，可以将函数的返回值保存在变量中。

```
def func():
    pass
    return "something"
result = func()
```

而对于同时返回多个值的函数，需要相应个数的变量来接收，变量之间以逗号分隔：

```
def func():
    return 1, [2, 3], "haha"

a, b, c = func()
```

### **参数的传递**

函数通常都有参数，用于将外部的实际数据传入函数内部进行处理。但是，在处理不同数据类型的参数时，会有不同的情况发生。这一切都是因为以下两点。

1. Python的函数参数传递的是实际对象的内存地址。
2. Python的数据类型分可变数据类型和不可变数据类型。

看下面的例子

```
a = 1
def func(a):
    print("在函数内部修改之前,变量a的内存地址为： %s" % id(a))
    a = 2
    print("在函数内部修改之后,变量a的内存地址为： %s" % id(a))
    print("函数内部的a为： %s" % a)


print("调用函数之前,变量a的内存地址为： %s" % id(a))
func(a)
print("函数外部的a为：%s" % a)
```

打印结果为：

```
调用函数之前,变量a的内存地址为： 1401140288
在函数内部修改之前,变量a的内存地址为： 1401140288
在函数内部修改之后,变量a的内存地址为： 1401140320
函数内部的a为： 2
函数外部的a为：1
```

为什么当a = 2之后，函数内外的a的内存地址就不一样了呢？也就是说此后函数内外的a是两个不同的对象了。

这是因为，当作为参数，a被传入函数时，将数字对象1的地址传递给了函数内部的a。执行第一句内部代码时，此时内部的a和外面的a其实是一个东西，因此打印出了同样的内存地址。而当a=2被执行后，创建了一个新的内部变量a，并赋值2，将数字对象2的内存地址赋给变量a。我们知道，首先，赋值语句具有创建新变量的功能，其次，函数由于存在作用域的概念（后面会介绍），在其内部的变量不受外部变量的影响，可以独立使用变量，相当于新的命名空间。因此，此时的a和外面的a没有一毛钱关系了，是两个不同的变量。同时，由于数字1和2是不可变的数字类型对象，是两个独立的，不同内存地址的对象，因此再次打印内存地址，当然就不一样了。

上面的解释可能不太好理解。其实，很多时候，我们被这种类似的问题困惑是因为函数参数的命名不恰当造成的。如果我们把上面的参数名改为b，可能就好理解多了（注意其中文字的变化）。执行结果是一样的。

```
a = 1

def func(b):
    print("在函数内部修改之前,变量b的内存地址为： %s" % id(b))
    b = 2
    print("在函数内部修改之后,变量b的内存地址为： %s" % id(b))
    print("函数内部的b为： %s" % b)


print("调用函数之前,变量a的内存地址为： %s" % id(a))
func(a)
print("函数外部的a为：%s" % a)
```

刚才说的是不可变类型参数，如果是可变类型的，比如列表呢？

```
a = [1, 2, 3]

def func(b):
    print("在函数内部修改之前,变量b的内存地址为： %s" % id(b))
    b.append(4)
    print("在函数内部修改之后,变量b的内存地址为： %s" % id(b))
    print("函数内部的b为： %s" % b)


print("调用函数之前,变量a的内存地址为： %s" % id(a))
func(a)
print("函数外部的a为：%s" % a)
```

执行结果是：

```
调用函数之前,变量a的内存地址为： 34875720
在函数内部修改之前,变量b的内存地址为： 34875720
在函数内部修改之后,变量b的内存地址为： 34875720
函数内部的b为： [1, 2, 3, 4]
函数外部的a为：[1, 2, 3, 4]
```

调用函数时将列表对象a的地址传递给了函数内部的变量b。`b.append(4)`的时候，根据传进来的内存地址，找到[1,2,3]这个列表对象，在它的后面添加了4。

可以看出，此时的a和b实际指向了同一个对象。为什么会这样？因为最关键的`b.append(4)`这句代码，它不同于“=”赋值语句，不会创建新的变量，而列表作为可变类型，具有append方法，这个方法只是对列表的一种调用而已。因此，a和b实际还是同一个对象。

那么，如果用数字类型调用append方法，会是什么结果呢？很明显，这是不行的，因为数字类型没有append方法，不是Python官方不给它设计，而是因为数字类型是不可变类型，永远不能有append方法。