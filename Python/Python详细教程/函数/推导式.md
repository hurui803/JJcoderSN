# 推导式

阅读: 9871   [评论](http://www.liujiangblog.com/course/python/36#comments)：11

Python语言有一种独特的推导式语法，相当于语法糖的存在，可以帮你在某些场合写出比较精简酷炫的代码。但没有它，也不会有太多的影响。Python语言有几种不同类型的推导式，下面逐一介绍：

### 1. 列表推导式

列表推导式是一种快速生成列表的方式。其形式是用方括号括起来的一段语句，如下例子所示：

```
lis = [x * x for x in range(1, 10)]

print(lis)
------------------------------------
结果：[1, 4, 9, 16, 25, 36, 49, 64, 81]
```

列表推导式要这么理解，首先执行for循环，对于每一个x，代入x*x中进行运算，将运算结果逐一添加到一个新列表内，循环结束，得到最终列表。它相当于下面的代码：

```
lis = []
for i in range(1, 10):
    lis.append(i*i)

print(lis)
```

列表推导式为我们提供了一种在一行内实现较为复杂逻辑的生成列表的方法。其核心语法是用中括号[]将生成逻辑封装起来。

列表推导式有多种花样用法：

- 增加条件语句

```
>>> [x * x for x in range(1, 11) if x % 2 == 0]
[4, 16, 36, 64, 100]
```

通过在后面添加if子句，对x进行过滤。

- 多重循环

```
>>> [a + b for a in ‘123' for b in ‘abc']
['1a', '1b', '1c', '2a', '2b', '2c', '3a', '3b', '3c']
```

同时循环a和b两个变量。

- 更多用法

```
>>> dic = {"k1":"v1","k2":"v2"}
>>> a = [k+":"+v for k,v in dic.items()]
>>> a
['k1:v1', 'k2:v2']
```

### 2. 字典推导式

既然使用中括号[]可以编写列表推导式，那么使用大括号呢？你猜对了！使用大括号{}可以制造字典推导式！

```
>>> dic = {x: x**2 for x in (2, 4, 6)}
>>> dic
{2: 4, 4: 16, 6: 36}
>>> type(dic)
<class 'dict'>
```

注意`x: x**2`的写法，中间的冒号，表示左边的是key右边的是value。

### 3. 集合推导式

大括号除了能用作字典推导式，还可以用作集合推导式，两者仅仅在细微处有差别。

```
>>> a = {x for x in 'abracadabra' if x not in 'abc'}
>>> a
{'d', 'r'}
>>> type(a)
<class 'set'>
```

仔细体会一下，表达式的写法差异！

### 4. 元组推导式？

报告老师，还有圆括号！是不是元组推导式？想法不错，但事实却没有。圆括号在Python中被用作生成器的语法了，很快我们就会讲到，没有元组推导式。

```
tup = (x for x in range(9))
print(tup)
print(type(tup))

---------------------------
结果：
<generator object <genexpr> at 0x000000000255DA98>
<class 'generator'>
```

要通过类似方法生成元组，需要显式调用元组的类型转换函数tuple()，如下所示：

```
tup = tuple(x for x in range(9))
print(tup)
print(type(tup))

------------------------
结果：
(0, 1, 2, 3, 4, 5, 6, 7, 8)
<class 'tuple'>
```

### 面试真题

看下面代码回答输出的结果是什么?为什么？

```
result = [lambda x: x + i for i in range(10)]
print(result[0](10))
```

这是一个结合了变量作用域、列表推导式和匿名函数的题目，较为复杂，比较考验Python基础知识掌握程度。有同学可能会回答10，其实答案是19，并且`result[0~9](10)`的结果都是19。

这是因为函数具有调用时才查找变量的特性。在你没调用它之前，它不会保存也不关心它内部变量的具体值。只有等到你调用它的时候，它才逐一去找这些变量的具体值。这里的result[0]被调用的时候，变量i已经循环完毕，变成9了，而不是想象中的动态0-9值。

那如果不想要这样的结果，想要i是循环的值怎么办?不要直接引用上层变量，把变量直接传进来。

```
result = [lambda x, i=i: x + i for i in range(10)]
print(result[0](10))
```